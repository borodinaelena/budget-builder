import { Directive, Inject, Injectable, InjectionToken, Input, NgModule, Optional, TemplateRef, ViewContainerRef } from '@angular/core';
import { __decorate, __metadata, __param } from 'tslib';
import { CommonModule } from '@angular/common';
import { map, takeUntil } from 'rxjs/operators';
import { Subject } from 'rxjs';

import * as ɵngcc0 from '@angular/core';
var NB_SECURITY_OPTIONS_TOKEN = new InjectionToken('Nebular Security Options');

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var shallowObjectClone = function (o) { return Object.assign({}, o); };
var ɵ0 = shallowObjectClone;
var shallowArrayClone = function (a) { return Object.assign([], a); };
var ɵ1 = shallowArrayClone;
var popParent = function (abilities) {
    var parent = abilities['parent'];
    delete abilities['parent'];
    return parent;
};
var ɵ2 = popParent;
/**
 * Common acl service.
 */
var NbAclService = /** @class */ (function () {
    function NbAclService(settings) {
        if (settings === void 0) { settings = {}; }
        this.settings = settings;
        this.state = {};
        if (settings.accessControl) {
            this.setAccessControl(settings.accessControl);
        }
    }
    NbAclService_1 = NbAclService;
    /**
     * Set/Reset ACL list
     * @param {NbAccessControl} list
     */
    NbAclService.prototype.setAccessControl = function (list) {
        for (var _i = 0, _a = Object.entries(list); _i < _a.length; _i++) {
            var _b = _a[_i], role = _b[0], value = _b[1];
            var abilities = shallowObjectClone(value);
            var parent_1 = popParent(abilities);
            this.register(role, parent_1, abilities);
        }
    };
    /**
     * Register a new role with a list of abilities (permission/resources combinations)
     * @param {string} role
     * @param {string} parent
     * @param {[permission: string]: string|string[]} abilities
     */
    NbAclService.prototype.register = function (role, parent, abilities) {
        if (parent === void 0) { parent = null; }
        if (abilities === void 0) { abilities = {}; }
        this.validateRole(role);
        this.state[role] = {
            parent: parent,
        };
        for (var _i = 0, _a = Object.entries(abilities); _i < _a.length; _i++) {
            var _b = _a[_i], permission = _b[0], value = _b[1];
            var resources = typeof value === 'string' ? [value] : value;
            this.allow(role, permission, shallowArrayClone(resources));
        }
    };
    /**
     * Allow a permission for specific resources to a role
     * @param {string} role
     * @param {string} permission
     * @param {string | string[]} resource
     */
    NbAclService.prototype.allow = function (role, permission, resource) {
        this.validateRole(role);
        if (!this.getRole(role)) {
            this.register(role, null, {});
        }
        resource = typeof resource === 'string' ? [resource] : resource;
        var resources = shallowArrayClone(this.getRoleResources(role, permission));
        resources = resources.concat(resource);
        this.state[role][permission] = resources
            .filter(function (item, pos) { return resources.indexOf(item) === pos; });
    };
    /**
     * Check whether the role has a permission to a resource
     * @param {string} role
     * @param {string} permission
     * @param {string} resource
     * @returns {boolean}
     */
    NbAclService.prototype.can = function (role, permission, resource) {
        this.validateResource(resource);
        var parentRole = this.getRoleParent(role);
        var parentCan = parentRole && this.can(this.getRoleParent(role), permission, resource);
        return parentCan || this.exactCan(role, permission, resource);
    };
    NbAclService.prototype.getRole = function (role) {
        return this.state[role];
    };
    NbAclService.prototype.validateRole = function (role) {
        if (!role) {
            throw new Error('NbAclService: role name cannot be empty');
        }
    };
    NbAclService.prototype.validateResource = function (resource) {
        if (!resource || [NbAclService_1.ANY_RESOURCE].includes(resource)) {
            throw new Error("NbAclService: cannot use empty or bulk '*' resource placeholder with 'can' method");
        }
    };
    NbAclService.prototype.exactCan = function (role, permission, resource) {
        var resources = this.getRoleResources(role, permission);
        return resources.includes(resource) || resources.includes(NbAclService_1.ANY_RESOURCE);
    };
    NbAclService.prototype.getRoleResources = function (role, permission) {
        return this.getRoleAbilities(role)[permission] || [];
    };
    NbAclService.prototype.getRoleAbilities = function (role) {
        var abilities = shallowObjectClone(this.state[role] || {});
        popParent(shallowObjectClone(this.state[role] || {}));
        return abilities;
    };
    NbAclService.prototype.getRoleParent = function (role) {
        return this.state[role] ? this.state[role]['parent'] : null;
    };
    var NbAclService_1;
    NbAclService.ANY_RESOURCE = '*';
    NbAclService = NbAclService_1 = __decorate([ __param(0, Optional()), __param(0, Inject(NB_SECURITY_OPTIONS_TOKEN)),
        __metadata("design:paramtypes", [Object])
    ], NbAclService);
NbAclService.ɵfac = function NbAclService_Factory(t) { return new (t || NbAclService)(ɵngcc0.ɵɵinject(NB_SECURITY_OPTIONS_TOKEN, 8)); };
NbAclService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NbAclService, factory: function (t) { return NbAclService.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbAclService, [{
        type: Injectable
    }], function () { return [{ type: Object, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [NB_SECURITY_OPTIONS_TOKEN]
            }] }]; }, null); })();
    return NbAclService;
}());

var NbRoleProvider = /** @class */ (function () {
    function NbRoleProvider() {
    }
    return NbRoleProvider;
}());

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
/**
 * Access checker service.
 *
 * Injects `NbRoleProvider` to determine current user role, and checks access permissions using `NbAclService`
 */
var NbAccessChecker = /** @class */ (function () {
    function NbAccessChecker(roleProvider, acl) {
        this.roleProvider = roleProvider;
        this.acl = acl;
    }
    /**
     * Checks whether access is granted or not
     *
     * @param {string} permission
     * @param {string} resource
     * @returns {Observable<boolean>}
     */
    NbAccessChecker.prototype.isGranted = function (permission, resource) {
        var _this = this;
        return this.roleProvider.getRole()
            .pipe(map(function (role) { return Array.isArray(role) ? role : [role]; }), map(function (roles) {
            return roles.some(function (role) { return _this.acl.can(role, permission, resource); });
        }));
    };
    NbAccessChecker = __decorate([ __metadata("design:paramtypes", [NbRoleProvider, NbAclService])
    ], NbAccessChecker);
NbAccessChecker.ɵfac = function NbAccessChecker_Factory(t) { return new (t || NbAccessChecker)(ɵngcc0.ɵɵinject(NbRoleProvider), ɵngcc0.ɵɵinject(NbAclService)); };
NbAccessChecker.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NbAccessChecker, factory: function (t) { return NbAccessChecker.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbAccessChecker, [{
        type: Injectable
    }], function () { return [{ type: NbRoleProvider }, { type: NbAclService }]; }, null); })();
    return NbAccessChecker;
}());

var NbIsGrantedDirective = /** @class */ (function () {
    function NbIsGrantedDirective(templateRef, viewContainer, accessChecker) {
        this.templateRef = templateRef;
        this.viewContainer = viewContainer;
        this.accessChecker = accessChecker;
        this.destroy$ = new Subject();
        this.hasView = false;
    }
    Object.defineProperty(NbIsGrantedDirective.prototype, "nbIsGranted", {
        set: function (_a) {
            var _this = this;
            var permission = _a[0], resource = _a[1];
            this.accessChecker.isGranted(permission, resource)
                .pipe(takeUntil(this.destroy$))
                .subscribe(function (can) {
                if (can && !_this.hasView) {
                    _this.viewContainer.createEmbeddedView(_this.templateRef);
                    _this.hasView = true;
                }
                else if (!can && _this.hasView) {
                    _this.viewContainer.clear();
                    _this.hasView = false;
                }
            });
        },
        enumerable: true,
        configurable: true
    });
    NbIsGrantedDirective.prototype.ngOnDestroy = function () {
        this.destroy$.next();
        this.destroy$.complete();
    };
    __decorate([
        Input(),
        __metadata("design:type", Array),
        __metadata("design:paramtypes", [Array])
    ], NbIsGrantedDirective.prototype, "nbIsGranted", null);
    NbIsGrantedDirective = __decorate([ __metadata("design:paramtypes", [TemplateRef,
            ViewContainerRef,
            NbAccessChecker])
    ], NbIsGrantedDirective);
NbIsGrantedDirective.ɵfac = function NbIsGrantedDirective_Factory(t) { return new (t || NbIsGrantedDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(NbAccessChecker)); };
NbIsGrantedDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NbIsGrantedDirective, selectors: [["", "nbIsGranted", ""]], inputs: { nbIsGranted: "nbIsGranted" } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbIsGrantedDirective, [{
        type: Directive,
        args: [{ selector: '[nbIsGranted]' }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }, { type: ɵngcc0.ViewContainerRef }, { type: NbAccessChecker }]; }, { nbIsGranted: [{
            type: Input
        }] }); })();
    return NbIsGrantedDirective;
}());

var NbSecurityModule = /** @class */ (function () {
    function NbSecurityModule() {
    }
    NbSecurityModule_1 = NbSecurityModule;
    NbSecurityModule.forRoot = function (nbSecurityOptions) {
        return {
            ngModule: NbSecurityModule_1,
            providers: [
                { provide: NB_SECURITY_OPTIONS_TOKEN, useValue: nbSecurityOptions },
                NbAclService,
                NbAccessChecker,
            ],
        };
    };
    var NbSecurityModule_1;
NbSecurityModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NbSecurityModule });
NbSecurityModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NbSecurityModule_Factory(t) { return new (t || NbSecurityModule)(); }, imports: [[
            CommonModule,
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NbSecurityModule, { declarations: function () { return [NbIsGrantedDirective]; }, imports: function () { return [CommonModule]; }, exports: function () { return [NbIsGrantedDirective]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbSecurityModule, [{
        type: NgModule,
        args: [{
                imports: [
                    CommonModule,
                ],
                declarations: [
                    NbIsGrantedDirective,
                ],
                exports: [
                    NbIsGrantedDirective,
                ]
            }]
    }], function () { return []; }, null); })();
    return NbSecurityModule;
}());

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */

/**
 * Generated bundle index. Do not edit.
 */

export { NB_SECURITY_OPTIONS_TOKEN, NbSecurityModule, NbAclService, ɵ0, ɵ1, ɵ2, NbAccessChecker, NbRoleProvider, NbIsGrantedDirective };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VzIjpbImluZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUVPO0FBQ1A7QUFDQTs7Ozs7Ozs7OztrQ0FBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUVPO0FBQ1A7Ozs7O2dHQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUVPO0FBQ1A7QUFDQTtBQUNBOzs7Ozs7OztvQkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O2dEQWF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRGlyZWN0aXZlLCBJbmplY3QsIEluamVjdGFibGUsIEluamVjdGlvblRva2VuLCBJbnB1dCwgTmdNb2R1bGUsIE9wdGlvbmFsLCBUZW1wbGF0ZVJlZiwgVmlld0NvbnRhaW5lclJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgX19kZWNvcmF0ZSwgX19tZXRhZGF0YSwgX19wYXJhbSB9IGZyb20gJ3RzbGliJztcbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBtYXAsIHRha2VVbnRpbCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzJztcblxudmFyIE5CX1NFQ1VSSVRZX09QVElPTlNfVE9LRU4gPSBuZXcgSW5qZWN0aW9uVG9rZW4oJ05lYnVsYXIgU2VjdXJpdHkgT3B0aW9ucycpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG52YXIgc2hhbGxvd09iamVjdENsb25lID0gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIG8pOyB9O1xudmFyIMm1MCA9IHNoYWxsb3dPYmplY3RDbG9uZTtcbnZhciBzaGFsbG93QXJyYXlDbG9uZSA9IGZ1bmN0aW9uIChhKSB7IHJldHVybiBPYmplY3QuYXNzaWduKFtdLCBhKTsgfTtcbnZhciDJtTEgPSBzaGFsbG93QXJyYXlDbG9uZTtcbnZhciBwb3BQYXJlbnQgPSBmdW5jdGlvbiAoYWJpbGl0aWVzKSB7XG4gICAgdmFyIHBhcmVudCA9IGFiaWxpdGllc1sncGFyZW50J107XG4gICAgZGVsZXRlIGFiaWxpdGllc1sncGFyZW50J107XG4gICAgcmV0dXJuIHBhcmVudDtcbn07XG52YXIgybUyID0gcG9wUGFyZW50O1xuLyoqXG4gKiBDb21tb24gYWNsIHNlcnZpY2UuXG4gKi9cbnZhciBOYkFjbFNlcnZpY2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTmJBY2xTZXJ2aWNlKHNldHRpbmdzKSB7XG4gICAgICAgIGlmIChzZXR0aW5ncyA9PT0gdm9pZCAwKSB7IHNldHRpbmdzID0ge307IH1cbiAgICAgICAgdGhpcy5zZXR0aW5ncyA9IHNldHRpbmdzO1xuICAgICAgICB0aGlzLnN0YXRlID0ge307XG4gICAgICAgIGlmIChzZXR0aW5ncy5hY2Nlc3NDb250cm9sKSB7XG4gICAgICAgICAgICB0aGlzLnNldEFjY2Vzc0NvbnRyb2woc2V0dGluZ3MuYWNjZXNzQ29udHJvbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgTmJBY2xTZXJ2aWNlXzEgPSBOYkFjbFNlcnZpY2U7XG4gICAgLyoqXG4gICAgICogU2V0L1Jlc2V0IEFDTCBsaXN0XG4gICAgICogQHBhcmFtIHtOYkFjY2Vzc0NvbnRyb2x9IGxpc3RcbiAgICAgKi9cbiAgICBOYkFjbFNlcnZpY2UucHJvdG90eXBlLnNldEFjY2Vzc0NvbnRyb2wgPSBmdW5jdGlvbiAobGlzdCkge1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gT2JqZWN0LmVudHJpZXMobGlzdCk7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgX2IgPSBfYVtfaV0sIHJvbGUgPSBfYlswXSwgdmFsdWUgPSBfYlsxXTtcbiAgICAgICAgICAgIHZhciBhYmlsaXRpZXMgPSBzaGFsbG93T2JqZWN0Q2xvbmUodmFsdWUpO1xuICAgICAgICAgICAgdmFyIHBhcmVudF8xID0gcG9wUGFyZW50KGFiaWxpdGllcyk7XG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyKHJvbGUsIHBhcmVudF8xLCBhYmlsaXRpZXMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZWdpc3RlciBhIG5ldyByb2xlIHdpdGggYSBsaXN0IG9mIGFiaWxpdGllcyAocGVybWlzc2lvbi9yZXNvdXJjZXMgY29tYmluYXRpb25zKVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSByb2xlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmVudFxuICAgICAqIEBwYXJhbSB7W3Blcm1pc3Npb246IHN0cmluZ106IHN0cmluZ3xzdHJpbmdbXX0gYWJpbGl0aWVzXG4gICAgICovXG4gICAgTmJBY2xTZXJ2aWNlLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uIChyb2xlLCBwYXJlbnQsIGFiaWxpdGllcykge1xuICAgICAgICBpZiAocGFyZW50ID09PSB2b2lkIDApIHsgcGFyZW50ID0gbnVsbDsgfVxuICAgICAgICBpZiAoYWJpbGl0aWVzID09PSB2b2lkIDApIHsgYWJpbGl0aWVzID0ge307IH1cbiAgICAgICAgdGhpcy52YWxpZGF0ZVJvbGUocm9sZSk7XG4gICAgICAgIHRoaXMuc3RhdGVbcm9sZV0gPSB7XG4gICAgICAgICAgICBwYXJlbnQ6IHBhcmVudCxcbiAgICAgICAgfTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IE9iamVjdC5lbnRyaWVzKGFiaWxpdGllcyk7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgX2IgPSBfYVtfaV0sIHBlcm1pc3Npb24gPSBfYlswXSwgdmFsdWUgPSBfYlsxXTtcbiAgICAgICAgICAgIHZhciByZXNvdXJjZXMgPSB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gW3ZhbHVlXSA6IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5hbGxvdyhyb2xlLCBwZXJtaXNzaW9uLCBzaGFsbG93QXJyYXlDbG9uZShyZXNvdXJjZXMpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQWxsb3cgYSBwZXJtaXNzaW9uIGZvciBzcGVjaWZpYyByZXNvdXJjZXMgdG8gYSByb2xlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHJvbGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGVybWlzc2lvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgc3RyaW5nW119IHJlc291cmNlXG4gICAgICovXG4gICAgTmJBY2xTZXJ2aWNlLnByb3RvdHlwZS5hbGxvdyA9IGZ1bmN0aW9uIChyb2xlLCBwZXJtaXNzaW9uLCByZXNvdXJjZSkge1xuICAgICAgICB0aGlzLnZhbGlkYXRlUm9sZShyb2xlKTtcbiAgICAgICAgaWYgKCF0aGlzLmdldFJvbGUocm9sZSkpIHtcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXIocm9sZSwgbnVsbCwge30pO1xuICAgICAgICB9XG4gICAgICAgIHJlc291cmNlID0gdHlwZW9mIHJlc291cmNlID09PSAnc3RyaW5nJyA/IFtyZXNvdXJjZV0gOiByZXNvdXJjZTtcbiAgICAgICAgdmFyIHJlc291cmNlcyA9IHNoYWxsb3dBcnJheUNsb25lKHRoaXMuZ2V0Um9sZVJlc291cmNlcyhyb2xlLCBwZXJtaXNzaW9uKSk7XG4gICAgICAgIHJlc291cmNlcyA9IHJlc291cmNlcy5jb25jYXQocmVzb3VyY2UpO1xuICAgICAgICB0aGlzLnN0YXRlW3JvbGVdW3Blcm1pc3Npb25dID0gcmVzb3VyY2VzXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChpdGVtLCBwb3MpIHsgcmV0dXJuIHJlc291cmNlcy5pbmRleE9mKGl0ZW0pID09PSBwb3M7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2hlY2sgd2hldGhlciB0aGUgcm9sZSBoYXMgYSBwZXJtaXNzaW9uIHRvIGEgcmVzb3VyY2VcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcm9sZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwZXJtaXNzaW9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHJlc291cmNlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgTmJBY2xTZXJ2aWNlLnByb3RvdHlwZS5jYW4gPSBmdW5jdGlvbiAocm9sZSwgcGVybWlzc2lvbiwgcmVzb3VyY2UpIHtcbiAgICAgICAgdGhpcy52YWxpZGF0ZVJlc291cmNlKHJlc291cmNlKTtcbiAgICAgICAgdmFyIHBhcmVudFJvbGUgPSB0aGlzLmdldFJvbGVQYXJlbnQocm9sZSk7XG4gICAgICAgIHZhciBwYXJlbnRDYW4gPSBwYXJlbnRSb2xlICYmIHRoaXMuY2FuKHRoaXMuZ2V0Um9sZVBhcmVudChyb2xlKSwgcGVybWlzc2lvbiwgcmVzb3VyY2UpO1xuICAgICAgICByZXR1cm4gcGFyZW50Q2FuIHx8IHRoaXMuZXhhY3RDYW4ocm9sZSwgcGVybWlzc2lvbiwgcmVzb3VyY2UpO1xuICAgIH07XG4gICAgTmJBY2xTZXJ2aWNlLnByb3RvdHlwZS5nZXRSb2xlID0gZnVuY3Rpb24gKHJvbGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGVbcm9sZV07XG4gICAgfTtcbiAgICBOYkFjbFNlcnZpY2UucHJvdG90eXBlLnZhbGlkYXRlUm9sZSA9IGZ1bmN0aW9uIChyb2xlKSB7XG4gICAgICAgIGlmICghcm9sZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOYkFjbFNlcnZpY2U6IHJvbGUgbmFtZSBjYW5ub3QgYmUgZW1wdHknKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTmJBY2xTZXJ2aWNlLnByb3RvdHlwZS52YWxpZGF0ZVJlc291cmNlID0gZnVuY3Rpb24gKHJlc291cmNlKSB7XG4gICAgICAgIGlmICghcmVzb3VyY2UgfHwgW05iQWNsU2VydmljZV8xLkFOWV9SRVNPVVJDRV0uaW5jbHVkZXMocmVzb3VyY2UpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOYkFjbFNlcnZpY2U6IGNhbm5vdCB1c2UgZW1wdHkgb3IgYnVsayAnKicgcmVzb3VyY2UgcGxhY2Vob2xkZXIgd2l0aCAnY2FuJyBtZXRob2RcIik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE5iQWNsU2VydmljZS5wcm90b3R5cGUuZXhhY3RDYW4gPSBmdW5jdGlvbiAocm9sZSwgcGVybWlzc2lvbiwgcmVzb3VyY2UpIHtcbiAgICAgICAgdmFyIHJlc291cmNlcyA9IHRoaXMuZ2V0Um9sZVJlc291cmNlcyhyb2xlLCBwZXJtaXNzaW9uKTtcbiAgICAgICAgcmV0dXJuIHJlc291cmNlcy5pbmNsdWRlcyhyZXNvdXJjZSkgfHwgcmVzb3VyY2VzLmluY2x1ZGVzKE5iQWNsU2VydmljZV8xLkFOWV9SRVNPVVJDRSk7XG4gICAgfTtcbiAgICBOYkFjbFNlcnZpY2UucHJvdG90eXBlLmdldFJvbGVSZXNvdXJjZXMgPSBmdW5jdGlvbiAocm9sZSwgcGVybWlzc2lvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRSb2xlQWJpbGl0aWVzKHJvbGUpW3Blcm1pc3Npb25dIHx8IFtdO1xuICAgIH07XG4gICAgTmJBY2xTZXJ2aWNlLnByb3RvdHlwZS5nZXRSb2xlQWJpbGl0aWVzID0gZnVuY3Rpb24gKHJvbGUpIHtcbiAgICAgICAgdmFyIGFiaWxpdGllcyA9IHNoYWxsb3dPYmplY3RDbG9uZSh0aGlzLnN0YXRlW3JvbGVdIHx8IHt9KTtcbiAgICAgICAgcG9wUGFyZW50KHNoYWxsb3dPYmplY3RDbG9uZSh0aGlzLnN0YXRlW3JvbGVdIHx8IHt9KSk7XG4gICAgICAgIHJldHVybiBhYmlsaXRpZXM7XG4gICAgfTtcbiAgICBOYkFjbFNlcnZpY2UucHJvdG90eXBlLmdldFJvbGVQYXJlbnQgPSBmdW5jdGlvbiAocm9sZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZVtyb2xlXSA/IHRoaXMuc3RhdGVbcm9sZV1bJ3BhcmVudCddIDogbnVsbDtcbiAgICB9O1xuICAgIHZhciBOYkFjbFNlcnZpY2VfMTtcbiAgICBOYkFjbFNlcnZpY2UuQU5ZX1JFU09VUkNFID0gJyonO1xuICAgIE5iQWNsU2VydmljZSA9IE5iQWNsU2VydmljZV8xID0gX19kZWNvcmF0ZShbXG4gICAgICAgIEluamVjdGFibGUoKSxcbiAgICAgICAgX19wYXJhbSgwLCBPcHRpb25hbCgpKSwgX19wYXJhbSgwLCBJbmplY3QoTkJfU0VDVVJJVFlfT1BUSU9OU19UT0tFTikpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW09iamVjdF0pXG4gICAgXSwgTmJBY2xTZXJ2aWNlKTtcbiAgICByZXR1cm4gTmJBY2xTZXJ2aWNlO1xufSgpKTtcblxudmFyIE5iUm9sZVByb3ZpZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE5iUm9sZVByb3ZpZGVyKCkge1xuICAgIH1cbiAgICByZXR1cm4gTmJSb2xlUHJvdmlkZXI7XG59KCkpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG4vKipcbiAqIEFjY2VzcyBjaGVja2VyIHNlcnZpY2UuXG4gKlxuICogSW5qZWN0cyBgTmJSb2xlUHJvdmlkZXJgIHRvIGRldGVybWluZSBjdXJyZW50IHVzZXIgcm9sZSwgYW5kIGNoZWNrcyBhY2Nlc3MgcGVybWlzc2lvbnMgdXNpbmcgYE5iQWNsU2VydmljZWBcbiAqL1xudmFyIE5iQWNjZXNzQ2hlY2tlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBOYkFjY2Vzc0NoZWNrZXIocm9sZVByb3ZpZGVyLCBhY2wpIHtcbiAgICAgICAgdGhpcy5yb2xlUHJvdmlkZXIgPSByb2xlUHJvdmlkZXI7XG4gICAgICAgIHRoaXMuYWNsID0gYWNsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciBhY2Nlc3MgaXMgZ3JhbnRlZCBvciBub3RcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwZXJtaXNzaW9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHJlc291cmNlXG4gICAgICogQHJldHVybnMge09ic2VydmFibGU8Ym9vbGVhbj59XG4gICAgICovXG4gICAgTmJBY2Nlc3NDaGVja2VyLnByb3RvdHlwZS5pc0dyYW50ZWQgPSBmdW5jdGlvbiAocGVybWlzc2lvbiwgcmVzb3VyY2UpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMucm9sZVByb3ZpZGVyLmdldFJvbGUoKVxuICAgICAgICAgICAgLnBpcGUobWFwKGZ1bmN0aW9uIChyb2xlKSB7IHJldHVybiBBcnJheS5pc0FycmF5KHJvbGUpID8gcm9sZSA6IFtyb2xlXTsgfSksIG1hcChmdW5jdGlvbiAocm9sZXMpIHtcbiAgICAgICAgICAgIHJldHVybiByb2xlcy5zb21lKGZ1bmN0aW9uIChyb2xlKSB7IHJldHVybiBfdGhpcy5hY2wuY2FuKHJvbGUsIHBlcm1pc3Npb24sIHJlc291cmNlKTsgfSk7XG4gICAgICAgIH0pKTtcbiAgICB9O1xuICAgIE5iQWNjZXNzQ2hlY2tlciA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBJbmplY3RhYmxlKCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbTmJSb2xlUHJvdmlkZXIsIE5iQWNsU2VydmljZV0pXG4gICAgXSwgTmJBY2Nlc3NDaGVja2VyKTtcbiAgICByZXR1cm4gTmJBY2Nlc3NDaGVja2VyO1xufSgpKTtcblxudmFyIE5iSXNHcmFudGVkRGlyZWN0aXZlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE5iSXNHcmFudGVkRGlyZWN0aXZlKHRlbXBsYXRlUmVmLCB2aWV3Q29udGFpbmVyLCBhY2Nlc3NDaGVja2VyKSB7XG4gICAgICAgIHRoaXMudGVtcGxhdGVSZWYgPSB0ZW1wbGF0ZVJlZjtcbiAgICAgICAgdGhpcy52aWV3Q29udGFpbmVyID0gdmlld0NvbnRhaW5lcjtcbiAgICAgICAgdGhpcy5hY2Nlc3NDaGVja2VyID0gYWNjZXNzQ2hlY2tlcjtcbiAgICAgICAgdGhpcy5kZXN0cm95JCA9IG5ldyBTdWJqZWN0KCk7XG4gICAgICAgIHRoaXMuaGFzVmlldyA9IGZhbHNlO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmJJc0dyYW50ZWREaXJlY3RpdmUucHJvdG90eXBlLCBcIm5iSXNHcmFudGVkXCIsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgcGVybWlzc2lvbiA9IF9hWzBdLCByZXNvdXJjZSA9IF9hWzFdO1xuICAgICAgICAgICAgdGhpcy5hY2Nlc3NDaGVja2VyLmlzR3JhbnRlZChwZXJtaXNzaW9uLCByZXNvdXJjZSlcbiAgICAgICAgICAgICAgICAucGlwZSh0YWtlVW50aWwodGhpcy5kZXN0cm95JCkpXG4gICAgICAgICAgICAgICAgLnN1YnNjcmliZShmdW5jdGlvbiAoY2FuKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNhbiAmJiAhX3RoaXMuaGFzVmlldykge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy52aWV3Q29udGFpbmVyLmNyZWF0ZUVtYmVkZGVkVmlldyhfdGhpcy50ZW1wbGF0ZVJlZik7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmhhc1ZpZXcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghY2FuICYmIF90aGlzLmhhc1ZpZXcpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudmlld0NvbnRhaW5lci5jbGVhcigpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5oYXNWaWV3ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE5iSXNHcmFudGVkRGlyZWN0aXZlLnByb3RvdHlwZS5uZ09uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95JC5uZXh0KCk7XG4gICAgICAgIHRoaXMuZGVzdHJveSQuY29tcGxldGUoKTtcbiAgICB9O1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0FycmF5XSlcbiAgICBdLCBOYklzR3JhbnRlZERpcmVjdGl2ZS5wcm90b3R5cGUsIFwibmJJc0dyYW50ZWRcIiwgbnVsbCk7XG4gICAgTmJJc0dyYW50ZWREaXJlY3RpdmUgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgRGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdbbmJJc0dyYW50ZWRdJyB9KSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtUZW1wbGF0ZVJlZixcbiAgICAgICAgICAgIFZpZXdDb250YWluZXJSZWYsXG4gICAgICAgICAgICBOYkFjY2Vzc0NoZWNrZXJdKVxuICAgIF0sIE5iSXNHcmFudGVkRGlyZWN0aXZlKTtcbiAgICByZXR1cm4gTmJJc0dyYW50ZWREaXJlY3RpdmU7XG59KCkpO1xuXG52YXIgTmJTZWN1cml0eU1vZHVsZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBOYlNlY3VyaXR5TW9kdWxlKCkge1xuICAgIH1cbiAgICBOYlNlY3VyaXR5TW9kdWxlXzEgPSBOYlNlY3VyaXR5TW9kdWxlO1xuICAgIE5iU2VjdXJpdHlNb2R1bGUuZm9yUm9vdCA9IGZ1bmN0aW9uIChuYlNlY3VyaXR5T3B0aW9ucykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmdNb2R1bGU6IE5iU2VjdXJpdHlNb2R1bGVfMSxcbiAgICAgICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgICAgIHsgcHJvdmlkZTogTkJfU0VDVVJJVFlfT1BUSU9OU19UT0tFTiwgdXNlVmFsdWU6IG5iU2VjdXJpdHlPcHRpb25zIH0sXG4gICAgICAgICAgICAgICAgTmJBY2xTZXJ2aWNlLFxuICAgICAgICAgICAgICAgIE5iQWNjZXNzQ2hlY2tlcixcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH07XG4gICAgfTtcbiAgICB2YXIgTmJTZWN1cml0eU1vZHVsZV8xO1xuICAgIE5iU2VjdXJpdHlNb2R1bGUgPSBOYlNlY3VyaXR5TW9kdWxlXzEgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgTmdNb2R1bGUoe1xuICAgICAgICAgICAgaW1wb3J0czogW1xuICAgICAgICAgICAgICAgIENvbW1vbk1vZHVsZSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgICAgICAgICBOYklzR3JhbnRlZERpcmVjdGl2ZSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBleHBvcnRzOiBbXG4gICAgICAgICAgICAgICAgTmJJc0dyYW50ZWREaXJlY3RpdmUsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9KVxuICAgIF0sIE5iU2VjdXJpdHlNb2R1bGUpO1xuICAgIHJldHVybiBOYlNlY3VyaXR5TW9kdWxlO1xufSgpKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEFrdmVvLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqL1xuXG4vKipcbiAqIEdlbmVyYXRlZCBidW5kbGUgaW5kZXguIERvIG5vdCBlZGl0LlxuICovXG5cbmV4cG9ydCB7IE5CX1NFQ1VSSVRZX09QVElPTlNfVE9LRU4sIE5iU2VjdXJpdHlNb2R1bGUsIE5iQWNsU2VydmljZSwgybUwLCDJtTEsIMm1MiwgTmJBY2Nlc3NDaGVja2VyLCBOYlJvbGVQcm92aWRlciwgTmJJc0dyYW50ZWREaXJlY3RpdmUgfTtcbiJdfQ==